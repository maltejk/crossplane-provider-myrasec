/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionsObservation struct {
	ActionID *int64 `json:"actionId,omitempty" tf:"action_id,omitempty"`

	Created *string `json:"created,omitempty" tf:"created,omitempty"`

	Modified *string `json:"modified,omitempty" tf:"modified,omitempty"`
}

type ActionsParameters struct {

	// +kubebuilder:validation:Optional
	AvailablePhases *int64 `json:"availablePhases,omitempty" tf:"available_phases,omitempty"`

	// +kubebuilder:validation:Optional
	CustomKey *string `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// +kubebuilder:validation:Optional
	ForceCustomValues *bool `json:"forceCustomValues,omitempty" tf:"force_custom_values,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionsObservation struct {
	AvailablePhases *int64 `json:"availablePhases,omitempty" tf:"available_phases,omitempty"`

	ConditionID *int64 `json:"conditionId,omitempty" tf:"condition_id,omitempty"`

	Created *string `json:"created,omitempty" tf:"created,omitempty"`

	ForceCustomValues *bool `json:"forceCustomValues,omitempty" tf:"force_custom_values,omitempty"`

	Modified *string `json:"modified,omitempty" tf:"modified,omitempty"`
}

type ConditionsParameters struct {

	// +kubebuilder:validation:Optional
	Alias *string `json:"alias,omitempty" tf:"alias,omitempty"`

	// +kubebuilder:validation:Optional
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	MatchingType *string `json:"matchingType,omitempty" tf:"matching_type,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type RuleObservation struct {
	Created *string `json:"created,omitempty" tf:"created,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Modified *string `json:"modified,omitempty" tf:"modified,omitempty"`

	RuleID *int64 `json:"ruleId,omitempty" tf:"rule_id,omitempty"`

	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`
}

type RuleParameters struct {

	// +kubebuilder:validation:Optional
	Actions []ActionsParameters `json:"actions,omitempty" tf:"actions,omitempty"`

	// +kubebuilder:validation:Required
	Conditions []ConditionsParameters `json:"conditions" tf:"conditions,omitempty"`

	// Your notes on this rule.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Phase specifies the condition under which a rule applies. Pre-origin means before your server (request), post-origin is past your server (response).
	// +kubebuilder:validation:Required
	Direction *string `json:"direction" tf:"direction,omitempty"`

	// Define wether this rule is enabled or not.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Expire date schedules the deaktivation of the WAF rule. If none is set, the rule will be active until manual deactivation.
	// +kubebuilder:validation:Optional
	ExpireDate *string `json:"expireDate,omitempty" tf:"expire_date,omitempty"`

	// A comment to identify the matching rule in the access log.
	// +kubebuilder:validation:Optional
	LogIdentifier *string `json:"logIdentifier,omitempty" tf:"log_identifier,omitempty"`

	// The rule name identifies each rule.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// After a rule has been applied, the rule chain will be executed as determined.
	// +kubebuilder:validation:Optional
	ProcessNext *bool `json:"processNext,omitempty" tf:"process_next,omitempty"`

	// The order in which the rules take action.
	// +kubebuilder:validation:Optional
	Sort *int64 `json:"sort,omitempty" tf:"sort,omitempty"`

	// The Subdomain for the WAF rule.
	// +kubebuilder:validation:Required
	SubdomainName *string `json:"subdomainName" tf:"subdomain_name,omitempty"`

	// +kubebuilder:validation:Optional
	Sync *bool `json:"sync,omitempty" tf:"sync,omitempty"`

	// +kubebuilder:validation:Optional
	Template *bool `json:"template,omitempty" tf:"template,omitempty"`
}

// RuleSpec defines the desired state of Rule
type RuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RuleParameters `json:"forProvider"`
}

// RuleStatus defines the observed state of Rule.
type RuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Rule is the Schema for the Rules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,myrasecjet}
type Rule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RuleSpec   `json:"spec"`
	Status            RuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RuleList contains a list of Rules
type RuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Rule `json:"items"`
}

// Repository type metadata.
var (
	Rule_Kind             = "Rule"
	Rule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Rule_Kind}.String()
	Rule_KindAPIVersion   = Rule_Kind + "." + CRDGroupVersion.String()
	Rule_GroupVersionKind = CRDGroupVersion.WithKind(Rule_Kind)
)

func init() {
	SchemeBuilder.Register(&Rule{}, &RuleList{})
}
