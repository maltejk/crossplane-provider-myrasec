/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type RecordObservation struct {
	Created *string `json:"created,omitempty" tf:"created,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Modified *string `json:"modified,omitempty" tf:"modified,omitempty"`

	RecordID *int64 `json:"recordId,omitempty" tf:"record_id,omitempty"`
}

type RecordParameters struct {

	// Define wether this subdomain should be protected by Myra or not.
	// +kubebuilder:validation:Optional
	Active *bool `json:"active,omitempty" tf:"active,omitempty"`

	// The alternative CNAME that points to the record.
	// +kubebuilder:validation:Optional
	AlternativeCname *string `json:"alternativeCname,omitempty" tf:"alternative_cname,omitempty"`

	// A comment to describe this DNS record.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// The Domain for the DNS record.
	// +kubebuilder:validation:Required
	DomainName *string `json:"domainName" tf:"domain_name,omitempty"`

	// Define wether this DNS record is enabled or not.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Subdomain name of a DNS record.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Port for SRV records.
	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`

	// Priority of MX records.
	// +kubebuilder:validation:Optional
	Priority *int64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// A record type to identify the type of a record. Valid types are: A, AAAA, MX, CNAME, TXT, NS, SRV and CAA.
	// +kubebuilder:validation:Required
	RecordType *string `json:"recordType" tf:"record_type,omitempty"`

	// Time to live.
	// +kubebuilder:validation:Required
	TTL *int64 `json:"ttl" tf:"ttl,omitempty"`

	// +kubebuilder:validation:Optional
	UpstreamOptions []UpstreamOptionsParameters `json:"upstreamOptions,omitempty" tf:"upstream_options,omitempty"`

	// Depends on the record type. Typically an IPv4/6 address or a domain entry.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type UpstreamOptionsObservation struct {
	Created *string `json:"created,omitempty" tf:"created,omitempty"`

	Modified *string `json:"modified,omitempty" tf:"modified,omitempty"`

	UpstreamID *int64 `json:"upstreamId,omitempty" tf:"upstream_id,omitempty"`
}

type UpstreamOptionsParameters struct {

	// Marks the server as a backup server. It will be used when the primary servers are unavailable. Cannot be used in combination with "Preserve client IP on the same upstream".
	// +kubebuilder:validation:Optional
	Backup *bool `json:"backup,omitempty" tf:"backup,omitempty"`

	// Marks the server as unavailable.
	// +kubebuilder:validation:Optional
	Down *bool `json:"down,omitempty" tf:"down,omitempty"`

	// Double usage: 1. Time period in which the max_fails must occur until the upstream is deactivated. 2. Time period the upstream is deactivated until it is reactivated. The time during which the specified number of unsuccessful attempts "Max fails" to communicate with the server should happen to consider the server unavailable. Also the period of time the server will be considered unavailable. Default is 10 seconds.
	// +kubebuilder:validation:Optional
	FailTimeout *int64 `json:"failTimeout,omitempty" tf:"fail_timeout,omitempty"`

	// The number of unsuccessful attempts to communicate with the server that should happen in the duration set by "Fail timeout" to consider the server unavailable. Also the server is considered unavailable for the duration set by "Fail timeout". By default, the number of unsuccessful attempts is set to 1. Setting the value to zero disables the accounting of attempts. What is considered an unsuccessful attempt is defined by the "Next upstream error handling".
	// +kubebuilder:validation:Optional
	MaxFails *int64 `json:"maxFails,omitempty" tf:"max_fails,omitempty"`

	// Weight defines the count of requests a upstream handles before the next upstream is selected.
	// +kubebuilder:validation:Optional
	Weight *int64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

// RecordSpec defines the desired state of Record
type RecordSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RecordParameters `json:"forProvider"`
}

// RecordStatus defines the observed state of Record.
type RecordStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RecordObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Record is the Schema for the Records API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,myrasecjet}
type Record struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RecordSpec   `json:"spec"`
	Status            RecordStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RecordList contains a list of Records
type RecordList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Record `json:"items"`
}

// Repository type metadata.
var (
	Record_Kind             = "Record"
	Record_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Record_Kind}.String()
	Record_KindAPIVersion   = Record_Kind + "." + CRDGroupVersion.String()
	Record_GroupVersionKind = CRDGroupVersion.WithKind(Record_Kind)
)

func init() {
	SchemeBuilder.Register(&Record{}, &RecordList{})
}
